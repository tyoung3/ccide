/* THISIS: simple.go.d */
package main

/*  	ccide - C Language Decision Table Code Generator 
	Copyright (C) 2002-2004,2010,2012,2022;  Thomas W. Young, e-mail:  ccide@twyoung.com

    	This file is part of ccide, the C Language Decision Table Code Generator.

   	Ccide is free software: you can redistribute it and/or modify
   	it under the terms of the GNU General Public License as published by
    	the Free Software Foundation, either version 3 of the License, or
   	(at your option) any later version.

    	Ccide is distributed in the hope that it will be useful,
    	but WITHOUT ANY WARRANTY; without even the implied warranty of
    	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    	GNU General Public License for more details.

    	You should have received a copy of the GNU General Public License
    	along with Ccide.  If not, see <http://www.gnu.org/licenses/> or
    	write to the Free Software Foundation, Inc., 51 Franklin St, 
    	Fifth Floor, Boston, MA 02110-1301 USA.
*/

import "fmt"

/*CCIDE_INLINE_CODE:*/
/*GENERATED_CODE:*/

/*
ccide-GO.m4
Copyright (C) 2002-2004,2010,2012,2022; Thomas W. Young, e-mail:  ccide@twyoung.com
 * The code generated by ccide is covered by the same license as the source  
 * code(decision table) from which it is derived. If you created the source,  
 * you are free to do anything you like with the generated code, 
 * including incorporating it into or linking it with proprietary software.  
*/
// ?? typedef unsigned int CCIDE_BIT;
var ccide_group int = 1

func CcideRuleLow(r *int, nbrrules int) bool {
	r=r+1
	if (r < nbrrules) {return }
	return false;
}

func CcideFindRule(               /* Return rule number */
	nbrrules int,  ccide_table CCIDE_BIT, yes[] CCIDE_BIT,  no[] CCIDE_BIT)  int  {
        r := 0;
        nstate := UINT_MAX ^ ccide_table;

///DECISION_TABLE:
// 1  1  1 | NEWGROUP		
// Y  -  - | yes[r] & nstate  
// -  Y  - | no[r]  & ccide_table  
// Y  Y  - | r+1 < nbrrules  
// ________|______________________  
// X  X  X | r=r+1
// -  -  0 | NEWGROUP		
//END_TABLE: 
/*GENERATED_CODE: FOR TABLE_1.*/
/*	3 Rules, 4 conditions, and 4 actions.*/
/*	Table 1 rule order = 1 2 3 */
 {	CCIDE_table1_yes := [...]uint{11, 13, 1}
	ccide_group:=1;

CCIDE_TABLE_1:
	switch(CcideFindRuleYes(3,
		  (ccide_group == 1)| (yes[r] & nstate)<<1| (no[r]  & ccide_table)<<2| (r+1 < nbrrules)<<3,
		  CCIDE_table1_yes)) {
	CCIDE_1_0: case 0:	/*	Rule 1*/
	CCIDE_1_1: case 1:	/*	Rule 2*/
	    r=r+1
	    goto CCIDE_TABLE_1;
	CCIDE_1_2: case 2:	/*	Rule 3*/
	    r=r+1
	} /* End Switch*/
/*END_GENERATED_CODE: FOR TABLE_1, by ccide-0.7.0-0 Wed 20 Jul 2022 10:35:43 AM EDT */

        return r;
}

func CcideFindRuleYes(             /* Return rule number */
	nbrrules int, ccide_table CCIDE_BIT, yes[] CCIDE_BIT) int {
        r := 0;

        nstate := UINT_MAX ^ ccide_table;
        while ( (yes[r] & nstate) && ( ++r < nbrrules ) ) {};
        return r;
}
/*END_GENERATED_CODE:*/
/*GENERATED_CODE: */
/* Substitution strings are: $$ and $@*/
/*END_GENERATED_CODE: */

func a1(n int) int {return n+1}
func a2(n int) int {return n+2}
func a3(n int) int {return n+3}

func main() {
	c2:=2;c3:=2;c4:=0  
	swvar[3][3]:={{2,3,4},{3,4,2},{4,3,0}} 

		/* N.B.: abort() is never executed.*/
	/*DECISION_TABLE:				*/
	/*   2  3  4 | swvar[c2][c3] == $$			*/
	/*   -  -  - | abort()				*/
        /*  _____ | _______             		*/
	/*   -  -  - | abort()				*/
	/*   -  -  X | a1(swvar[c2][c3]);				*/
	/*   1  2  3 | printf("Rule: %i\n", $$ );		*/
	/*   -  X  X | a2(swvar[c2][c3]);				*/
	/*   X  X  - |NEWGROUP		*/
        /*END_TABLE:					*/
	/*GENERATED_CODE: FOR TABLE_1.*/
	/*	3 Rules, 3 conditions, and 7 actions.*/
	/*	Table 1 rule order = 1 2 3 */
	 {	CCIDE_BIT CCIDE_table1_yes[3]={1UL, 2UL, 4UL};
		ccide_group=1;

	CCIDE_TABLE_1:
		switch(CcideFindRuleYes(3,(swvar[c2][c3] == 2)
			| (swvar[c2][c3] == 3)<<1
			| (swvar[c2][c3] == 4)<<2
			  ,CCIDE_table1_yes)) {
		CCIDE_1_1: case 1:	/*	Rule 2*/
		    printf("Rule: %i\n", 2 );
		    a2(swvar[c2][c3]);
		    goto CCIDE_TABLE_1;
		CCIDE_1_0: case 0:	/*	Rule 1*/
		    printf("Rule: %i\n", 1 );
		    goto CCIDE_TABLE_1;
		CCIDE_1_2: case 2:	/*	Rule 3*/
		    a1(swvar[c2][c3]);
		    printf("Rule: %i\n", 3 );
		    a2(swvar[c2][c3]);
		    break;
		} /* End Switch*/
	/*END_GENERATED_CODE: FOR TABLE_1, by ccide-0.7.0-0  */

	//DECISION_TABLE:
	//   Y  N  Y |c4
	//   -  N  Y |c2
	//   N  Y  - |c3
	//---|--
	//   -  -  X |a3(swvar[c2][c3]);
	//   X  -  X |a1(swvar[c2][c3]);
	//   X  X  - |a2(swvar[c2][c3]);
	//END_TABLE:
	/*GENERATED_CODE: FOR TABLE_2.*/
	/*	3 Rules, 3 conditions, and 3 actions.*/
	/*	Table 2 rule order = 2 3 1 */
	 {	CCIDE_BIT CCIDE_table2_yes[3]={4UL, 3UL, 1UL};
	CCIDE_BIT CCIDE_table2_no[3]={3UL, 0UL, 4UL};


		switch(CcideFindRule(3,
			  (c4)
			| (c2)<<1
			| (c3)<<2
			  ,CCIDE_table2_yes, CCIDE_table2_no)) {
		CCIDE_2_2: case 2:	/*	Rule 1*/
		    a1(swvar[c2][c3]);
		CCIDE_2_0: case 0:	/*	Rule 2*/
		    a2(swvar[c2][c3]);
		    break;
		CCIDE_2_1: case 1:	/*	Rule 3*/
		    a3(swvar[c2][c3]);
		    a1(swvar[c2][c3]);
		    break;
		} /* End Switch*/
	/*END_GENERATED_CODE: FOR TABLE_2, by ccide-0.7.0-0  */



	return 0;
}
