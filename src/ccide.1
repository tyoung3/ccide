.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CCIDE 1"
.TH CCIDE 1 "2022-07-18" "ccide-0.7.0-0" "DecisionTableProcessor(ccide) Man Page"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ccide \- Decision Table Code Generator
.PP
Ccide preprocesses a source code file (written in one of several programming languages) containing embedded,commented decision tables.  
Ccide generates a compilable source file with verified, expanded,  decision logic.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBccide\fR [ \-a] [\-b] [\-c \s-1COLSIZE\s0] [\-d \s-1SUBSTITUTE_STRING1 SUBSTITUTE_STRING2\s0 ] [\-e] [\-g] [\-l] [\-L C|\*(C+|CC|CH|CS|BASH|BASIC|EX|JAVA|VB|QB] 
		 [\-m4] [\-n] [\-p \s-1PREFIX\s0] [\-q \s-1LEFTQUOTE RIGHTQUOTE\s0] [\-s \s-1SKELSIZE\s0] [\-t] 
 		 [\-u] [\-x] < \s-1FILEIN\s0 > \s-1FILEOUT\s0
.PP
\&\fBccide\fR [\-V] | [\-\-version]
.PP
\&\fBccide\fR [\-s [nnn] ]
.PP
\&\fBccide\fR [\-\-help]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Ccide reads a source code file containing embedded decision tables 
from \s-1STDIN,\s0 analyzes, expands the tables, and writes a compilable source file.
.PP
The output from ccide can be modified (or not) then used as input to ccide
subsequently.   In other words, if ccide is run as follows:
	ccide \-b < foobar.d | tee foobar.c | ccide \-b > foobar.t
then foobar.c will be identical to foobar.t.  (The \-b option suppresses
the timestamps that would otherwise cause differences.)
.PP
All statements not within a decision table are copied unchanged to
\&\s-1STDOUT,\s0 except that Ccide ignores(deletes) all the statements 
between '//GENERATED_CODE:' and '//END_GENERATED_CODE:' statements.
.PP
Decision tables are analyzed and written to \s-1STDOUT.\s0  Generated
code is written to \s-1STDOUT,\s0 surrounded by the comment statements:
\&'//GENERATED_CODE:' and '//END_GENERATED_CODE:'.
.PP
(\s-1NOTE:\s0 comments in other languages may use delimiters other than the '//'
delimiter used by \*(C+ and C.)
.PP
If the statement '//CCIDE_INLINE_CODE:' is encountered, ccide generates
definitions of CcideFindRule... functions.  This code follows
the '//CCIDE_INLINE_CODE:' statement and is surrounded by
\&'//...GENERATED_CODE:' statements.  If the input contains multiple
\&'//CCIDE_INLINE_CODE:' statements, only the first will be expanded.
.PP
A decision table takes the following general form:
.PP
.Vb 11
\& //DECISION_TABLE:
\& // c0,0 c0,1 c0,2 ... c0,r | e0
\& // c1,0 c1,1 c1,2 ... c1,r | e1
\& //     ...
\& // cn,0 cn,1 cn,2 ... cn,r | en
\& //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- | \-\-
\& // r0,0 r0,1 r0,2 ... r0,r | a0
\& // r1,0 r1,1 r1,2 ... r1,r | a0
\& //     ...
\& // rm,0 rm,1 rm,2 ... rm,r | a0
\& //END_TABLE:
\&
\& The \*(Aq//\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- | \-\-\*(Aq (or, alternate, as in \*(Aq//_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\*(Aq)  statement is required.  There may
\&be any number of spaces, hyphens(\-), and underscores(_); but no other characters except for a single, optional, fence, \*(Aq|\*(Aq.  The current parser may allow multiple fences, but this is not guaranteed. 
\&
\& where  c0,0 ... cn,r   (condition entries) can be Y(yes), N(no), \-(don\*(Aqt 
\&                        care), or a decimal integer from 0 to 99; 
\&
\&        r               is the number of rules; a rule is defined by a 
\&                        vertical column of conditions and actions.
\&
\&        n               is the number of condition rows;
\&
\&        |               is a \*(Aqfence\*(Aq which divides the rule entries (left 
\&                        side) from the  condition stub or action stub on 
\&                        the right side;
\&
\&        e0 ... en       are conditional expressions in the source program language;
\&
\&        r0,0 ... rm,r   (action entries) can be X(act), \-(don\*(Aqt care), or 
\&                        a decimal number from 0 to 99;  \*(Aq#\*(Aq and \*(Aq/\*(Aq characters
\&                        will be ignored, by the current parser.
\&
\&        a0 ... am       are action stubs in the source program language.
\&
\&        m               is the number of action rows.
.Ve
.PP
Decision table statements may be preceded with whitespace(blanks and tab characters).   The generated output will duplicate the whitespace
preceding the '//DECISION_TABLE:' statement.
.PP
There is no provision for commentary within a table, except that comments may appear in stub entries. However, if all entries are  \*(L"don't care\*(R" entries, then the statement is effectively a comment.
.PP
Ccide analyzes the table then copies the table to \s-1STDOUT,\s0 followed by the generated code.  Every conditional expression is evaluated just once and in the order of appearance in the table.  If all the condition entries are \*(L"Don't care\*(R", the condition is not evaluated, since the condition cannot affect the logical outcome.
.PP
The order in which rules appear in the table should not affect the results.
To accomplish this, ccide reorders the rules internally, placing more specific rules in front of less specific rules.  When two rules are equally specific, condition entry ranking is used to break the tie.
Condition entry ranking gives higher priority to conditions nearer the beginning (top) of the table.
A comment is generated showing the resulting rule ordering.  For example,
.PP
.Vb 4
\&        //DECISION_TABLE:
\&        // Y \- | cond1
\&        // \- Y | cond2
\&        //    ...
.Ve
.PP
will generate
.PP
.Vb 1
\&        //      Table 1 rule order = 1 2
.Ve
.PP
Condition ranking gives priority to condition entries in row order:
.PP
.Vb 4
\&        //DECISION_TABLE:
\&        // \- Y | cond1
\&        // Y \- | cond2
\&        //    ...
.Ve
.PP
generates
.PP
.Vb 1
\&        //      Table 1 rule order = 2 1
.Ve
.PP
because the cond1 'Y'  appears before the cond2 'Y'. ('N' would have the same effect.)
While the order of condition rows may affect the rule ordering, this should not change the program results, unless the table is specified ambiguously, as in the example above.  The example is ambiguous if  cond1 and cond2 can both be true.  
Condition entry ranking removes the ambiguity based on the condition row order.  This design makes output strictly deterministic.
.PP
If integers appear as condition or action entries, a '$$' in the row stub will be replaced by the entry integer.  A separate row is generated, in effect, for each unique digit that appears as a rule entry in the original row.
.PP
If \s-1NEWGROUP\s0 appears as a condition stub, ccide will generate code to test the group variable against the integers supplied in the condition entries.  Effectively, ccide will replace \*(L"\s-1NEWGROUP\*(R"\s0 with \*(L"ccide_group == $$\*(R".
.PP
If '\s-1NEWGROUP\s0' appears as the last action stub, the integer variable, 'ccide_group' (initially = 1), will be assigned the integer value specified in the appropriate rule and the table will be re-entered from the beginning.  This has the effect of combining two, or more, smaller tables into one larger table. There should be a corresponding condition stub which checks for the ccide_group value.  Like this:
.PP
.Vb 5
\&        1 2 2 2 2 3 | NEWGROUP
\&                  ....
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&                  ....
\&        2 2 2 2 3 \- | NEWGROUP
.Ve
.PP
In the preceding example, the decision table will be left(not re-entered) when rule 6 finally takes effect.
.PP
If '$@' appears in an action stub, ccide will replace the $@ with the name of the decision table entry point.  This is mainly useful when \s-1NEWGROUP\s0 is not used in an action stub \*(-- something like this:
.PP
.Vb 1
\&        X \- | goto $@;
.Ve
.PP
Note that the substitution delimiters(\*(L"$$\*(R" and \*(L"$@\*(R" may be replaced with other delimiters by invoking the '\-d' option on the command line.
.PP
Ccide employs one of two functions, CcideFindRule or CcideFindRuleYes, in a 'switch' statement to select actions to be taken.  The numbers in the generated 'case' statements do not correspond to the decision table rule numbers, so a comment is appended to the case statement giving the  number of the applicable rule, starting with rule 1 at the leftmost column.
.PP
Ccide optimizes case output sequence by reordering cases so as to minimize action stub generation redundancy.
.PP
All cases are labeled with a string showing the table number and the case number.  This allows ccide to use goto's to reduce the amount of output in some situations. The \fB\-g\fR option disables this optimization.
.PP
Ccide reduces the amount of generated code by combining cases wherever appropriate.  I.e., if two cases specify the same set of actions, the actions are generated only once, preceded by the two case statements.
.PP
Regardless of any other reordering, ccide always evaluates conditions in the sequence given in the decision table.  Actions(when taken) are also performed in the order given.  This strategy helps avoid problems with side effects.
.PP
The function, CcideFindRuleYes, is employed when there are no 'N'
condition entries in the table.  Performance will be somewhat improved
in this case. There is no corresponding, CcideFindRuleNo, function.  In
the highly unusual situation where there are no 'Y' condition entries,
ccide performance can be improved slightly by reversing the logic of all the
condition stubs and replacing all the 'N' condition entries with 'Y'
entries.
.PP
In the special case where a single condition row containing integers(and at most
one '\-'(don't care) is specified and the condition stub is in the form
of:	'... | \s-1EXPRESSION\s0 == $$ ' 
ccide will generate more efficient code replacing the
CcideFindRule.. function with a switch(\s-1EXPRESSION\s0) statement, and use
the row integers in  case statements.  \s-1NEWGROUP\s0 may be specified as the
last action, and will cause a 'goto' back to the switch statement. 
However, the ccide-group variable will not be set.  Highly complex state
machines depending on N variables can be efficiently defined by using an
N dimensioned array to contain the state values for N variables.
.PP
For the special case with two rules and one condition, ccide generates
an if/else statement.  For one rule and one condition, ccide generates
an if statement.
.PP
See ccidemain.c or one of the '...LANG.d' test case files for examples of decision
tables.
.PP
Alphabetic entries (Y,N, and X) may be upper or lower case.   Generated 
entries will be upper case.
.PP
Ccide is a wrapper script for ccidew, the actual decision table processing
engine.   For C language tables, ccidew generates all the output.  For
other languages, ccidew generates m4 output which is then processed 
by the m4 macro processor.  There is no guarantee that this arrangement will continue in 
future releases.  In other words, use 'ccide' not 'ccidew' in your projects.
.SH "OPTIONS"
.IX Header "OPTIONS"
\&\fB\-a|\-\-actiondupes\fR	Normally, ccide considers duplicate action stubs to be an error.  Code is generated, but error messages are issued
and the return code is set to 1.
The \fB\-a\fR option permits duplicate actions and bypasses all the error messages.
.PP
\&\fB\-b|\-\-blanktime\fR	The \fB\-b\fR(\-\-blanktime) option causes ccide to bypass timestamping output.
.PP
\&\fB\-c|\-\-columnsize)\fR	The \fB\-c\fR(\-\-columnsize) option sets the number of characters that ccide assigns to each output rule.
.PP
\&\fB\-d|\-\-delimiter\fR	The \fB\-d\fR(\-\-delimiter) option repaces the two stub substitution
strings (\*(L"$$\*(R" and \*(L"$@\*(R") with \s-1SUBSTITUTE_STRING1\s0 and \s-1SUBSTITUTE_STRING2,\s0 respectively.
\&\s-1SUBSTITUTE_STRING1\s0 and \s-1SUBSTITUTE_STRING2\s0 may be any reasonable size, but may not be \s-1NULL,\s0 nor
may \s-1SUBSTITUTE_STRING1\s0 equal \s-1SUBSTITUTE_STRING2.\s0  Neither string may contain a single
quote \*(L"'\*(R" nor a back quote \*(L"`\*(R".   These two quote characters are used
as delimiters by m4.  If there are multiple \-d options the last one
remains in effect.
.PP
.Vb 7
\&        If \-L BASH is specified, "$$" and "$@" are replaced with "/::" and "@@/".
\&These can be replaced using the B<\-d> option after the <\-L> option.
\&If, for instance, ccide \-L BASH \-d "/!!!" "&&&/"  is specified, 
\&the delimiters "/!!!" and "&&&/" will be used.  It is almost always a good
\&idea to avoid quotes(\*(Aq\`"), brackets([]), braces({}), semicolons(;),
\&number signs(#), dollar signs($), hyphens(\-), backslashes(\e), 
\&and underscores(_) in bash delimiters.
.Ve
.PP
\&\fB\-e|\-\-equalok\fR	ccide normally checks condition stub expressions for 
a single equal sign '=' (double equal sign '==' is \s-1OK\s0), and 
issues an error message if one is found.   The
\&\fB\-e\fR option bypasses this check.    This option is automatic
for euphoria programs (lang=ex).
.PP
.Vb 5
\&        If the \-m4 output option is in effect, single quotes ("\*(Aq") and  
\&backquotes("\`") are not allowed in condition or action stubs.  
\&For BASH scripts use the, "$(command)", form of command substitution 
\&instead of the back quote form, "\`command\`".  Use functions, as 
\&necessary, to avoid syntax problems with quotes.
.Ve
.PP
\&\fB\-g|\-\-gotoless\fR   Eliminate \s-1GOTO\s0 statements.  ccide optimizes some complex switch expressions using \s-1GOTO\s0 statements.  This option will elminate \s-1GOTO\s0 optimization.  Languages, such as JavaScript, which disallow \s-1GOTO,\s0 automatically invoke this option.
.PP
\&\fB\-k|\-\-quiet\fR		The \-\-quiet option causes ccide to bypass issuing warning messages.  Empty rules and actions will be silently dropped.
.PP
\&\fB\-l|\-\-localtime\fR	The \fB\-l\fR(\-\-localtime) option causes ccide to use local time
instead of \s-1UTC\s0 on timestamps.
.PP
\&\fB\-L|\-\-language\fR	The \fB\-L\fR(\-\-language) option determines the output programming language for ccide.  If there are multiple \-L options, the last one  remains in effect.  '\-L ?' will cause ccide to display a list of supported languages and exit with return code 2.
.PP
\&\fB\-m4|\-\-m4output\fR	Produce m4 output instead of C code.  The m4 output can be used to create language independent decision table code.  This option is useful when working with an unsupported language, as with a domain specific language.
.PP
\&\fB\-n|\-\-noinlinecode\fR	The \fB\-n\fR option causes ccide to suppress the generation
of inline code when the \*(L"//CCIDE_INLINE_CODE:\*(R" statement 
is encountered.  This is useful when multiple source files
contain the \*(L"//CCIDE_INLINE_CODE:\*(R" statement.
.PP
\&\fB\-p|\-\-prefix\fR   The \fB\-p\fR \s-1STRING\s0 option changes the \*(L"\s-1CCIDE\*(R"\s0 prefix in generated code
to the supplied \s-1STRING.\s0  \s-1STRING\s0 can contain only alphanumeric
characters and the underscore('_').
.PP
\&\fB\-q|\-\-quote\fR   The \fB\-q\fR(\-\-quote) option changes the characters ccide uses
in output m4 macros from the default \*(L"`\*(R" and \*(L"'\*(R" to the supplied
\&\s-1LEFTQUOTE\s0 and \s-1RIGHTQUOTE\s0 strings, which must differ from each other
and from the ccide delimiters.
.PP
.Vb 5
\&        If \-L BASH has been specified, "^^^" and "%%%" replace the
\&LEFTQUOTE and RIGHTQUOTE strings, "\`" and "\*(Aq", in order to 
\&reduce the possibility of ambiguous m4 output.  It is not a good
\&idea to replace these strings later in the command line, since the
\&supplied BASH m4 macro file depends on these.
.Ve
.PP
\&\fB\-s|\-\-skeleton\fR	The \fB\-s [n]\fR option causes ccide to produce an example, skeleton,
program on \s-1STDOUT,\s0 then terminate with return code 0.  
The \fB\-s\fR option can be followed by an optional integer(default 4)
defining the size of the table.  You can test ccide this way, 
\&'ccide \-s 10 | ccide ',  without having a decision table of your own.
.PP
\&\fB\-t|\-\-trace\fR	The \fB\-t\fR(trace) option causes ccide to set the parser 
yydebug parameter.  This will cause the parser to issue
a flood of debugging messages on \s-1STDERR.\s0
.PP
\&\fB\-u|\-\-undo\fR	The \fB\-u\fR(undo) option causes ccide to not generate
any code, effectively recreating its original input.
.PP
\&\fB\-V|\-\-version\fR	The \fB\-V\fR option causes ccide to display the software version
and a copyright notice on \s-1STDERR,\s0 and terminate with return code 0.
.PP
\&\fB\-x|\-\-extrarule\fR	The \fB\-x\fR option causes ccide to add a \*(L"don't care\*(R" rule to every
decision table.   Multiple \fB\-x\fR options cause multiple rules
to be added.  This option is intended to save clerical effort
when adding rules to tables.  A don't care rule can also serve
to complete a table (an incomplete table does not account for
all condition permutations).  Ccide does not check to ensure that
tables are complete, as most real world tables are incomplete 
and it would become annoying to keep pointing them out.
.PP
\&\fB\-\-help\fR 
	The \fB\-\-help\fR  option causes ccide to display a ccide usage
synopsis on \s-1STDOUT\s0 and terminate with return code 0.
.SH "RETURN VALUE"
.IX Header "RETURN VALUE"
Ccide normally returns 0.  1 is returned if an error is found in
a decision table.
.SH "ERRORS"
.IX Header "ERRORS"
The message \*(L"Rule x conflicts with rule y\*(R"  is written to \s-1STDERR,\s0 when two
rules conflict.  The message is also copied to \s-1STDOUT.\s0  The program
continues, but the return code is changed to 1.
.PP
The message \*(L"Rules x and  y overlap.\*(R" is issued when some rule has no effect \*(-- because another rule subsumes it.  
The program is not terminated and the  return code is not set \*(-- remains 0, unless other errors are detected.
.PP
A usage message is issued when the '\-\-help' option is supplied or if some option is not recognizable.
.PP
The message \*(L"Error in line ...: Inconsistent number of rules. near ''. State=7\*(R"
is written to \s-1STDERR\s0 and a more informative message is written to 
\&\s-1STDOUT\s0 when a row is found with the wrong number of rule entries.
.PP
The message \*(L"\s-1NEWGROUP\s0 not supported for GOTOless languages.\*(R" is written to
\&\s-1STDERR\s0 and \s-1STDOUT\s0 if '\s-1NEWGROUP\s0' is specified in an action stub and the target
language does not support \s-1GOTO.\s0  This problem may be resolved in a future release
if there is suffiecient interest.
.PP
Error messages are issued and the return code is set to 1, if a condition
stub or action stub exactly matches a preceding condition or action stub,
respectively.  The \fB\-a\fR option allows duplicate actions without any errors.
.PP
Unless the \fB\-e\fR option is specified, ccide will issue an error message
when a single equal sign(=) is encountered in a condition stub 
expression.   (A single equal sign is almost always a logic error \*(-- in C programs, anyway.)
.SH "INSTALLING and CONFIGURING"
.IX Header "INSTALLING and CONFIGURING"
See the accompanying \s-1INSTALL\s0 and \s-1README\s0 files.   
Ccide does not consult any configuration or rc files.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
.Vb 6
\&        /*  The beginning of the program. */
\&  #ifdef CCIDE_LIB
\&  #include <ccide.h>
\&  #else
\&  //CCIDE_INLINE_CODE:
\&  #endif
\&
\&        /* Supporting code */
\&  //DECISION_TABLE:
\&  //  1 3 2 2 | light == $$   /* 1=red, 2= yellow, 3=green. */
\&  //  N \- \- \- | speed == STOPPED
\&  //  \- \- Y \- | speed == SLOW
\&  //  \- N \- Y | speed == FAST
\&  // _\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_
\&  //  X \- X \- | Stop();
\&  //  \- \- \- X | SlowDown();
\&  //  \- X \- \- | SpeedUp();
\&  //END_TABLE:
\&    /*  End of the program. */
.Ve
.PP
Explanation:
.PP
The //CCIDE_INLINE_CODE: statement causes ccide to generate the CcideFindRule... functions in source form. To avoid linkedit clashes, only one module in a multi-module program should contain these functions.
.PP
The #ifdef \s-1CCIDE_LIB ...\s0 logic gives the compiler a chance to eliminate the generated functions; to link the program with a separately compiled module later on.   In this case, the ccide.h file provides prototypes for the CcideFindRule... functions.
.PP
Rule 1 states that if the light is red and your car is moving,
then stop.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
The ccide script uses the environment variable \s-1CCIDEW\s0 to locate the
ccidew program.   Ordinarily, the script will locate the ccidew program
correctly and set the variable, so the user need not do so.  In some
testing situations, however, where there is ambiguity as to which version
of ccidew should be invoked, it is useful to set the \s-1CCIDEW\s0 variable to
the full path of the correct executable.
.PP
The ccide script uses the environment variable \s-1CCIDE_M4DIR\s0 to locate
the directory containing the .m4 files needed to expand other than C
language files.  If \s-1CCIDE_M4DIR\s0 is not set, or the .m4 files are missing,
ccide will search in the data directory (usually /usr/share/ccide)  and then in the current directory.
.SH "FILES"
.IX Header "FILES"
Ccide reads \s-1STDIN\s0 and writes to \s-1STDOUT\s0 and \s-1STDERR.\s0  There is a 'ccide\-LANG.m4'
file for each supported language, other than C, where \s-1LANG\s0 = \s-1CC,\*(C+,CS,BASH,BASIC,EX,QB,VB,\s0 or \s-1JAVA.\s0
.SH "PORTABILITY"
.IX Header "PORTABILITY"
It is intended for ccide to be distributed as widely as possible and be portable
to all systems capable of compliling C code.  To this end ccidew, relies
strictly on the C compiler,  preprocessor,  standard C library, and linker.  
The ccide wrapper script is relatively straight forward and not 
strictly required for C programs.
.PP
M4 is required only for processing other than C language input.  Anyway,
m4 is itself widely distributed.
.PP
It is intended that future versions of ccide will be backward compatible, i.e.
if this version of ccide produces correct, compilable output, any future 
version will also.
.PP
The current scheme of using a wrapper script, ccide, and separate executable will
continue unless a new ccide program replaces them both \*(-- a very unlikely event,
as this would raise many portability issues.
.SH "BUGS"
.IX Header "BUGS"
.RS 4
Ccide may not work correctly on all platforms or some non-C languages, 
as C/\*(C+ language code has been tested most extensively.  
Ccide may not work correctly on Mingw.  Ccide will most likely fail 
if the input file is in \s-1DOS\s0 format rather than *nix format.
.Sp
Valgrind displays some minor memory leaks.   This should not effect the results.
.Sp
If you find a new bug, please send a message to ccide@twyoung.com and/or
create an issue at https://www.github.com/tyoung3/ccide.
.Sp
The output with the 'undo' option may not be exactly the
same as the original input \*(-- some whitespace may be added or deleted.
.Sp
There is no provision for continuing a row onto the next line.
.Sp
The documentation needs improving.
.Sp
Ccide\-0.6.4\-1 and prior versions have known bugs. Please install
the latest version before reporting bugs.
.RE
.SH "RESTRICTIONS"
.IX Header "RESTRICTIONS"
There can no more than 32 conditions or 2048 actions or 256 rules
in a single decision table.
.PP
Ccide imposes no limit on the number of decision tables in a single module or program. 
Neither does Ccide impose any limit on the number of statements in a program.
.SH "TODO"
.IX Header "TODO"
.IP "Globalize." 4
.IX Item "Globalize."
.PD 0
.IP "Port to more platforms, starting with Mingw." 4
.IX Item "Port to more platforms, starting with Mingw."
.IP "Improve the documentation." 4
.IX Item "Improve the documentation."
.IP "Write the inverse program, 'edicc', to create decision tables from C source (or from any source language)." 4
.IX Item "Write the inverse program, 'edicc', to create decision tables from C source (or from any source language)."
.PD
.SH "REPORTING BUGS"
.IX Header "REPORTING BUGS"
Please e\-mail ccide@twyoung.com, with 'ccide' in the subject,
if you have a bug (or other comment, request, etc ) to report.
.SH "AUTHOR"
.IX Header "AUTHOR"
Thomas W. Young, ccide@twyoung.com
.PP
==head1 \s-1COPYRIGHT\s0
.PP
Copyright 2002\-2012, 2022, Thomas W. Young, The \s-1CCIDE\s0 Project, ccide@twyoung.com.
Permission is granted to copy, distribute and/or modify this document under the terms of the \s-1GNU\s0 Free Documentation
License, Version 1.2 or any later version published by the Free Software Foundation; with the Invariant Sections being
\&\*(L"\s-1GNU\s0 General Public License\*(R" and \*(L"Funding Free Software\*(R", the Front-Cover texts being (a) (see below), and with the Back\-
Cover Texts being (b) (see below).  A copy of the license is included in the \fBgfdl\fR\|(7) man page.
.PP
.Vb 1
\&        (a)The FSF\*(Aqs Front\-Cover text is:
\&
\&                A GNU Manual
\&
\&        (b)The FSF\*(Aqs Back\-Cover text is:
\&
\&            You have freedom to copy and modify this GNU Manual, like GNU
\&            software.  Copies published by the Free Software Foundation raise
\&            funds for GNU development.
.Ve
.SH "AVAILABILITY"
.IX Header "AVAILABILITY"
This software is freely available under the \s-1GPL\s0 license agreement terms
spelled out in the accompanying \s-1COPYING\s0 file.
.PP
ccide is part of the \s-1GNU\s0 project: http://www.gnu.org/gnu/thegnuproject.html.
.PP
Ccide is available as a public Github project at https://github.com/tyoung3/ccide
The latest code can be found at Github.
.PP
Released packages  are available from SourceForge at
	http://www.sourceforge.net/projects/ccide
