.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CCIDE 1"
.TH CCIDE 1 "2012-06-30" "ccide-0.5.0" "DecisionTableProcessor(ccide) Man Page"
.SH "NAME"
ccide \- Decision Table Code Generator
.PP
Expand embedded decision tables and copy supporting code to generate
compilable or interpretable code.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBccide\fR [ \-a] [\-b] [\-c \s-1COLSIZE\s0] [\-d \s-1SUBSTITUTE_STRING1\s0 \s-1SUBSTITUTE_STRING2\s0 ] [\-e] [\-l] [\-L C|CC|CH|CS|BASH|BASIC|EX|JAVA|VB|QB] 
		 [\-m4] [\-n] [\-p \s-1PREFIX\s0] [\-q \s-1LEFTQUOTE\s0 \s-1RIGHTQUOTE\s0] [\-s \s-1SKELSIZE\s0] [\-t] 
 		 [\-u] [\-x] < \s-1FILEIN\s0 > \s-1FILEOUT\s0  
.PP
\&\fBccide\fR [\-V]  		
.PP
\&\fBccide\fR [\-s [nnn] ]  		
.PP
\&\fBccide\fR [\-\-help] 	
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
ccide reads a source file of C source code containing embedded decision tables 
from \s-1STDIN\s0, analyzes, and expands the tables. 
.PP
The output from ccide can be modified (or not) then used as input to ccide
subsequently.   In other words if ccide is run as follows:
	ccide \-b < foobar.d | tee foobar.c | ccide \-b > foobar.t
then foobar.c will be identical to foobar.t.  (The \-b option suppresses
the timestamps that would otherwise cause differences.)
.PP
All statements not within a decision table are copied unchanged to
\&\s-1STDOUT\s0.  Decision tables are analyzed and written to \s-1STDOUT\s0.  Generated
code is written to \s-1STDOUT\s0, surrounded by the statements:
\&'//GENERATED_CODE:' and '//END_GENERATED_CODE:'.
.PP
If the two '//...GENERATED_CODE:' statements appear in the input file,
ccide ignores them and all the statements in between.
.PP
If the statement '//CCIDE_INLINE_CODE:' is encountered, ccide generates
definitions of CcideFindRule... functions.  This code follows
the '//CCIDE_INLINE_CODE:' statement and is surrounded by
\&'//...GENERATED_CODE:' statements.  If the input contains multiple/P
\&'//CCIDE_INLINE_CODE:' statements, only the first will be expanded.
.PP
A decision table takes the following general form:
.PP
.Vb 11
\& //DECISION_TABLE:
\& // c0,0 c0,1 c0,2 ... c0,r | e0
\& // c1,0 c1,1 c1,2 ... c1,r | e1
\& //     ...
\& // cn,0 cn,1 cn,2 ... cn,r | en
\& //------------------------ | --
\& // r0,0 r0,1 r0,2 ... r0,r | a0
\& // r1,0 r1,1 r1,2 ... r1,r | a0
\& //     ...
\& // rm,0 rm,1 rm,2 ... rm,r | a0
\& //END_TABLE:
.Ve
.PP
.Vb 4
\& The '//-----------------------------' statement is required.  There may
\&be any number of spaces hyphens(-) and underscores(_), but no other
\&characters except for a single, optional, fence, '|'.  The current
\&parser allows multiple fences, but this is not guaranteed.
.Ve
.PP
.Vb 2
\& where  c0,0 ... cn,r   (condition entries) can be Y(yes), N(no), -(don't 
\&                        care), or a decimal integer from 0 to 99;
.Ve
.PP
.Vb 3
\&        r               is the number of rules; a rule is defined by a 
\&                        vertical column of conditions and actions through 
\&                        a table;
.Ve
.PP
.Vb 1
\&        n               is the number of condition rows;
.Ve
.PP
.Vb 3
\&        |               is a 'fence' which divides the rule entries (left 
\&                        side) from the  condition stub or action stub on 
\&                        the right side;
.Ve
.PP
.Vb 1
\&        e0 ... en       are conditional expressions;
.Ve
.PP
.Vb 3
\&        r0,0 ... rm,r   (action entries) can be X(act), -(don't care), or 
\&                        a decimal number from 0 to 99;  '#' and '/' characters
\&                        will be ignored, by the current parser.
.Ve
.PP
.Vb 1
\&        a0 ... am       are action stubs -- program language dependent code;
.Ve
.PP
.Vb 1
\&        m               is the number of action rows.
.Ve
.PP
Decision table statements may be preceded with whitespace(blanks and
tab characters).   The generated output will duplicate the whitespace
preceding the '//DECISION_TABLE:' statement.
.PP
There is no provision for commentary within a table, except as
comments may appear in stub entries. However, if all entries are
\&\*(L"don't care\*(R" entries, then the statement is effectively a comment. 
.PP
Ccide analyzes the table, copies the table to \s-1STDOUT\s0, followd by generated
code.  Every conditional expression is evaluated just once and
in the order of appearance in the table.  In case all the condition
entries are \*(L"Don't care\*(R", the condition is not evaluated, since the
condition cannot affect the logical outcome.  
.PP
When analyzing the table, ccide reorders the rules, placing the more 
specific rules in front of less specific rules.   You can safely assume 
that the order of rules in the table has no effect on the resulting 
program and accordingly you should enter rules in whatever order is most 
convenient(readable).  
.PP
If integers appear as condition or action entries, a '$$' in the row stub
will be replaced by the entry integer.  A separate row is generated, in
effect, for each unique digit that appears as a rule entry in the original
row.   
.PP
If \s-1NEWGROUP\s0 appears as a condition stub, ccide will generate
code to test the group variable against the integers supplied in
the condition entries.  Effectively, ccide will replace \*(L"\s-1NEWGROUP\s0\*(R"
with \*(L"ccide_group == $$\*(R".
.PP
If '\s-1NEWGROUP\s0' appears as the last action stub, the integer variable,
\&'ccide_group' (initially = 1), will be assigned the integer value specified
in the appropriate rule and the table will be re-entered from the
beginning.  This has the effect of combining two, or more, smaller tables
into one larger table. There should be a corresponding condition stub
which checks for the ccide_group value.  Like this:
.PP
.Vb 5
\&        1 2 2 2 2 3 | NEWGROUP
\&                  ....
\&        -----------------------
\&                  ....
\&        2 2 2 2 3 - | NEWGROUP
.Ve
.PP
In the preceding example, the decision table will be left(not
re\-entered) when rule 6 finally takes effect. 
.PP
If '$@' appears in an action stub, ccide will replace the $@ with
the name of the decision table entry point.  This is mainly useful when
\&\s-1NEWGROUP\s0 is not used in an action stub \*(-- something like this:
.PP
.Vb 1
\&        X - | goto $@;
.Ve
.PP
Note that the substitution delimiters(\*(L"$$\*(R" and \*(L"$@\*(R" may be replaced by
invoking the '\-d' option on the command line.
.PP
Ccide employs one of two functions, CcideFindRule or CcideFindRuleYes, in a
\&'switch' statement to select actions to be taken.  The numbers in the
generated 'case' statements do not correspond to the decision table rule 
numbers, so a comment is appended to the case statement giving the 
number of the applicable rule, starting with rule 1 at the leftmost column.   
.PP
Ccide optimizes case output sequence by reordering cases so as to
minimize action stub generation redundancy.  
.PP
All cases are labeled with a string showing the table number and the case
number.  This allows ccide to use goto's to reduce the amount of output in
some situations.
.PP
Ccide reduces the amount of generated code by combining cases wherever
appropriate.  I.e., if two cases specify the same set of actions, the
actions are generated only once, preceded by the two case statements. 
.PP
Regardless of any other reordering, ccide always evaluates conditions in
the sequence given in the decision table.  Actions(when taken) are also
performed in the order given.  This strategy helps avoid problems with
side effects. 
.PP
The function, CcideFindRuleYes, is employed when there are no 'N'
condition entries in the table.  Performance will be somewhat improved
in this case. There is no corresponding, CcideFindRuleNo, function.  In
the highly unusual situation where there are no 'Y' condition entries,
ccide performance can be improved slightly by reversing the logic of all the
condition stubs and replacing all the 'N' condition entries with 'Y'
entries.
.PP
In the special case where a single condition row containing integers(and
no '\-'s(don't care) is specified and the condition stub is in the form
of:
	... | \s-1EXPRESSION\s0 == $$ 
.PP
ccide will generate more efficient 'state machine' code replacing the
CcideFindRule.. function with a switch(\s-1EXPRESSION\s0) statement, and using
the row integers in a case statement.  \s-1NEWGROUP\s0 may be specified as the
last action, and will cause a 'goto' back to the switch statement. 
However, the ccide-group variable will not be set.  Highly complex state
machines depending on N variables can be efficiently defined by using an
N dimensioned array to contain the state values for N variables. 
.PP
See ccidemain.c or one of the '.in' suffix files for examples of decision
tables.   
.PP
Alphabetic entries (Y,N, and X) may be upper or lower case.   Generated 
entries will be upper case. 
.PP
Ccide is a wrapper script for, ccidew, the actual decision table processing
engine.   For C language tables, ccidew generates all the output.  For
other languages, ccidew generates M4 output which is processed by the m4 macro
processor.  There is no guarantee that this arrangement will continue in 
future releases.  In other words, use 'ccide' not 'ccidew' in your projects. 
.SH "OPTIONS"
.IX Header "OPTIONS"
\&\fB\-a\fR	Normally, ccide considers duplicate action stubs to be
	an error.  Code is generated \s-1OK\s0, but error messages are issued
	and the return code is set to 1.
	The \fB\-a\fR options allows duplicate actions and bypasses all the
	error messages.
.PP
\&\fB\-b\fR	The \fB\-b\fR(blanktime) option causes ccide to bypass
	timestamping output.
.PP
\&\fB\-c\fR	The \fB\-c\fR(colum size) option sets the number of characters that ccide
	assigns to each output rule.
.PP
\&\fB\-d\fR	The \fB\-d\fR(\s-1CCIDE\s0 Delimiter) option repaces the two stub substitution
	strings (\*(L"$$\*(R" and \*(L"$@\*(R") with \s-1SUBSTITUTE_STRING1\s0 and \s-1SUBSTITUTE_STRING2\s0, respectively.
	\s-1SUBSTITUTE_STRING1\s0 and \s-1SUBSTITUTE_STRING2\s0 may be any reasonable size, but may not be \s-1NULL\s0, nor
	may \s-1SUBSTITUTE_STRING1\s0 equal \s-1SUBSTITUTE_STRING2\s0.  Neither string may contain a single
	quote \*(L"'\*(R" nor a back quote \*(L"`\*(R".   These two quote characters are used
	as delimiters by m4.  In case of multiple \-d options the last one
	remains in effect.  
.PP
.Vb 7
\&        If -L BASH is specified, "$$" and "$@" are replaced with "/::" and "@@/".
\&        These can be replaced using the B<-d> option after the <-L> option.
\&        If, for instance, ccide -L BASH -d "/!!!" "&&&/"  is specified, 
\&        the delimiters "/!!!" and "&&&/" will be used.  It is almost always a good
\&        idea to avoid quotes('`"), brackets([]), braces({}), semicolons(;),
\&        number signs(#), dollar signs($), hyphens(-), backslashes(\e), 
\&        and underscores(_) in bash delimiters.
.Ve
.PP
\&\fB\-e\fR	ccide normally checks condition stub expressions for 
	a single equal sign '=' (double equal sign '==' is \s-1OK\s0), and 
	issues an error message if one is found.   The
	\fB\-e\fR option bypasses this check.    This option is automatic
	for euphoria programs (lang=ex). 
.PP
.Vb 5
\&        If the -m4 output option is in effect, single quotes ("'") and  
\&        backquotes("`") are not allowed in condition or action stubs.  
\&        For BASH scripts use the, "$(command)", form of command substitution 
\&        instead of the back quote form, "`command`".  Use functions, as 
\&        necessary, to avoid syntax problems with quotes.
.Ve
.PP
\&\fB\-l\fR	The \fB\-l\fR(localtime) option causes ccide to use local time
	instead of \s-1UTC\s0 on timestamps.
.PP
\&\fB\-L\fR	The \fB\-L\fR(language) option determines the output programming language
	for ccide.  In case of multiple \-L options, the last one 
	remains in effect.  '\-L ?' will cause ccide to display a list of supported languages and exit with return code 2.
.PP
\&\fB\-m4\fR	Produce m4 output instead of C code.  The m4 output can be
	used to create language independent decision table code.
	This option is useful when working with an unsupported
	language as with a domain specific language.  
.PP
\&\fB\-n\fR	The \fB\-n\fR option causes ccide to suppress the generation
	of inline code when the \*(L"//CCIDE_INLINE_CODE:\*(R" statement 
	is encountered.  This is useful when multiple source files
	contain the \*(L"//CCIDE_INLINE_CODE:\*(R" statement.
.PP
\&\fB\-p\fR   The \fB\-p\fR \s-1STRING\s0 option changes the \*(L"\s-1CCIDE\s0\*(R" prefix in generated code
	to the supplied \s-1STRING\s0.  \s-1STRING\s0 can contain only alphanumeric
	characters and the underscore('_').   
.PP
\&\fB\-q\fR   The \fB\-q\fR(m4 quote) option changes the characters ccide uses
	in output m4 macros from the default \*(L"`\*(R" and \*(L"'\*(R" to the supplied
	\s-1LEFTQUOTE\s0 and \s-1RIGHTQUOTE\s0 strings, which must differ from each other
	and from the ccide delimiters.  
.PP
.Vb 5
\&        In case -L BASH has been specified, "^^^" and "%%%" replace the
\&        LEFTQUOTE and RIGHTQUOTE strings, "`" and "'", in order to 
\&        reduce the possibility of ambiguous m4 input.  It is not a good
\&        idea to replace these strings later in the command line, since the
\&        supplied BASH m4 macro file depends on these.
.Ve
.PP
\&\fB\-s\fR	The \fB\-s [n]\fR option causes ccide to produce an example, skeleton,
	program on \s-1STDOUT\s0, then terminate with return code 0.  
	The \fB\-s\fR option can be followed by an optional integer(default 4)
	defining the size of the table.  You can test ccide this way, 
	'ccide \-s 10 | ccide ',  without having a decision table of your own. 
.PP
\&\fB\-t\fR	The \fB\-t\fR(trace) option causes ccide to set the parser 
	yydebug parameter.  This will cause the parser to issue
	a flood of debugging messages on \s-1STDERR\s0.
.PP
\&\fB\-u\fR	The \fB\-u\fR(undo) option causes ccide to not generate
	any code, effectively recreating its original input.
.PP
\&\fB\-V\fR	The \fB\-V\fR option causes ccide to display the software version
and a copyright notice on \s-1STDERR\s0, and terminate with return code 0.
.PP
\&\fB\-x\fR	The \fB\-x\fR option causes ccide add a \*(L"don't care\*(R" rule to every
	decision table.   Multiple \fB\-x\fR options cause multiple rules
	to be added.  This option is intended to save clerical effort
	when adding rules to tables.  A don't care rule can also serve
	to complete a table (an incomplete table does not account for
	all condition permutations).  Ccide does not check to ensure that
	tables are complete, as most real world tables are incomplete 
	and it would become annoying to keep pointing them out.
.PP
\&\fB\-\-help\fR 
	The \fB\-\-help\fR  option causes ccide to display a ccide usage
	synopsis on \s-1STDOUT\s0 and terminate with return code 0.
.SH "RETURN VALUE"
.IX Header "RETURN VALUE"
Ccide normally returns 0.  1 is returned if an error is found in
a decision table.
.SH "ERRORS"
.IX Header "ERRORS"
The message \*(L"Rule x conflicts with rule y\*(R"  is written to \s-1STDERR\s0, when two
rules conflict.  The message is also copied to \s-1STDOUT\s0.  The program
continues, but the return code is changed to 1.
.PP
The message \*(L"Rules x and  y overlap.\*(R" is issued when a rule
cannot take effect.   The program is not terminated and the 
return code is not set \*(-- will be 0, unless other errors are detected.
.PP
A usage message is issued when the '\-\-help' option is supplied or if an
option is not recognizable. 
.PP
The message \*(L"Error in line ...: Inconsistent number of rules. near ''. State=7\*(R"
is written to \s-1STDERR\s0 and a more informative message is written to 
\&\s-1STDOUT\s0 when a row is found with the wrong number of rule entries.
.PP
Error messages are issued and the return code is set to 1, if a condition
stub or action stub exactly matches a preceding condition or action stub,
respectively.  The \fB\-a\fR option allows duplicate actions without any errors.
.PP
Unless the \fB\-e\fR option is specified, ccide will issue an error message
when a single equal sign(=) is encountered in a condition stub 
expression.   (A single equal sign is almost always a logic error \*(-- in C programs, anyway.)
.SH "INSTALLING and CONFIGURING"
.IX Header "INSTALLING and CONFIGURING"
See the accompanying \s-1INSTALL\s0 and \s-1README\s0 files.   
Ccide does not consult any configuration or rc files. 
.SH "EXAMPLE"
.IX Header "EXAMPLE"
.Vb 6
\&        /*  The beginning of the program. */
\&  #ifdef CCIDE_LIB
\&  #include <ccide.h>
\&  #else
\&  //CCIDE_INLINE_CODE:
\&  #endif
.Ve
.PP
.Vb 12
\&        /* Supporting code */
\&  //DECISION_TABLE:
\&  //  1 3 2 2 | light == $$   /* 1=red, 2= yellow, 3=green. */
\&  //  N - - - | speed == STOPPED
\&  //  - - Y - | speed == SLOW
\&  //  - N - Y | speed == FAST
\&  // _________________________
\&  //  X - X - | Stop();
\&  //  - - - X | SlowDown();
\&  //  - X - - | SpeedUp();
\&  //END_TABLE:
\&    /*  End of the program. */
.Ve
.PP
Explanation:
	The //CCIDE_INLINE_CODE: statement causes ccide to
	generate the CcideFindRule... functions in source form. 
	To avoid linkedit clashes, only one module in a 
	multi-module program should contain these functions.
.PP
.Vb 5
\&        The #ifdef CCIDE_LIB ... logic gives the
\&        compiler a chance to eliminate the generated functions;
\&        to link the program with a separately compiled
\&        module later on.   In this case, the ccide.h file provides
\&        prototypes for the CcideFindRule... functions.
.Ve
.PP
.Vb 2
\&        Rule 1 states that if the light is red and your car is moving,
\&        then stop.
.Ve
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
The ccide script uses one environment variable, \s-1CCIDEW\s0; to locate the
ccidew program.   Ordinarily, the script will locate the ccidew program
correctly and set the variable, so the user need not do so.  In some
testing situations, however, where there is ambiguity as to which version
of ccidew should be invoked, it is useful to set the \s-1CCIDEW\s0 variable to
the full path of the correct executable. 
.SH "FILES"
.IX Header "FILES"
Ccide reads \s-1STDIN\s0 and writes to \s-1STDOUT\s0 and \s-1STDERR\s0.  There is an 'ccide\-LANG.m4'
file for each language other than C, where \s-1LANG\s0 = \s-1CC\s0,\*(C+,CS,BASH,BASIC,EX,QB,VB, or \s-1JAVA\s0. 
These m4 files are normally in the /usr/share/ccide directory. 
.SH "PORTABILITY"
.IX Header "PORTABILITY"
It is intended for ccide to be distributed as widely as possible and be portable
to all systems capable of compliling C code.  To this end ccidew, relies
strictly on the C compiler,  preprocessor,  standard C library, and linker.  
The ccide wrapper script is relatively straight forward and not 
strictly required for C programs.
.PP
M4 is required only for processing other than C language input.  Anyway,
m4 is itself widely distributed. 
.PP
It is intended that future versions of ccide will be backward compatible, i.e.
if this version of ccide produces correct, compilable output, any future 
version will also. 
.PP
The current scheme of using a wrapper script, ccide, and separate executable will
continue unless a new ccide program replaces them both \*(-- a very unlikely event,
as this would raise some new portability issues. 
.SH "BUGS"
.IX Header "BUGS"
.IP "There are no known bugs, but ccide may not work correctly for some non-C languages, as C language code has been tested most extensively.  No bugs have ever been reported, however." 4
.IX Item "There are no known bugs, but ccide may not work correctly for some non-C languages, as C language code has been tested most extensively.  No bugs have ever been reported, however."
.PD 0
.IP "The output with the 'undo' option may not be exactly the same as the original input \*(-- some whitespace may be added or deleted." 4
.IX Item "The output with the 'undo' option may not be exactly the same as the original input  some whitespace may be added or deleted."
.IP "There is no provision for continuing a row onto the next line." 4
.IX Item "There is no provision for continuing a row onto the next line."
.IP "The documentation needs improving." 4
.IX Item "The documentation needs improving."
.PD
.SH "RESTRICTIONS"
.IX Header "RESTRICTIONS"
There can no more than 32 condition rows or 32 action rows or 32 rules
in a single decision table.  Make smaller tables out of large tables for more understandable programs. 
.Sp
Ccide imposes no limit on the number of decision tables in a single module or program. 
Neither does Ccide impose any limit on the number of statements in a program.
.SH "TODO"
.IX Header "TODO"
.RS 4
.IP "Globalize." 4
.IX Item "Globalize."
.PD 0
.IP "Port to more platforms." 4
.IX Item "Port to more platforms."
.IP "Improve the documentation." 4
.IX Item "Improve the documentation."
.IP "Write the inverse program, 'edicc', to create decision tables from C source (or from any source language)." 4
.IX Item "Write the inverse program, 'edicc', to create decision tables from C source (or from any source language)."
.RE
.RS 4
.PD
.SH "REPORTING BUGS"
.IX Header "REPORTING BUGS"
Please e\-mail ccide@twyoung.com, with 'ccide' in the subject,
if you have a bug (or other comment, request, etc ) to report.
.SH "AUTHOR"
.IX Header "AUTHOR"
Thomas W. Young, ccide@twyoung.com
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright © 2002\-2012, Thomas W. Young, The \s-1CCIDE\s0 Project, ccide@twyoung.com.
This is free software under the \s-1GNU\s0 Public License, \s-1GPL\s0; 
see the accompanying \s-1COPYING\s0 file for copying conditions. 
.Sp
Please note that the \s-1GPL\s0 imposes no license or distribution restrictions
on programs which are developed using ccide.
.Sp
There is \s-1NO\s0 warranty; not even for \s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A
\&\s-1PARTICULAR\s0 \s-1PURPOSE\s0.
.SH "AVAILABILITY"
.IX Header "AVAILABILITY"
This software is freely available under the \s-1GPL\s0 license agreement terms
spelled out in the accompanying \s-1COPYING\s0 file.  
.Sp
\&'\e<!\-\-#include virtual=\*(L"/inc/sfinfo.shtml\*(R"\-\-\e>'
.Sp
Ccide is a public Github project at https://github.com/tyoung3/ccide
The latest version can be found at Github.
.Sp
Older versions are available from SourceForge at
	http://www.sourceforge.net/projects/ccide
